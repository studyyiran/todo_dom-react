<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="./init.js"></script>
    <script src="../../util/component.js"></script>
    <script src="../../util/util.js"></script>
    <script src="./input.js"></script>
    <style>
        .list_input_container_finishIcon {
            border-radius: 50%;
            border: 1px solid gray;
            min-width: 10px;
            max-width: 10px;
            height: 10px;
            margin-right: 10px;
        }
        .list_input_container_content {
            max-width: 300px;
            min-width: 300px;
            flex: 1;
        }
        .list_input_container {
            padding: 10px;
            border-bottom: 1px solid gray;
            display: flex;
            align-items: center;
            width: 400px;
        }
        .list_input_container_textarea {
            flex: 1;
        }
    </style>
</head>
<body>
    <div id="root1"></div>
    <div id="root2"></div>
    <div id="root3"></div>
</body>
<script>
    let Input1 = new window.Components.Input();
    function myFunc() {
        return {
            type: 'div',
            props: {class: 'fatherOfAll'},
            children: [
                'success or fail? is not important.',
                Input1.render(),
            ]
        }
    }
    // 为什么不能搜索到prototype
    // 因为我们不能引用同一个。我们需要每个调用setRootRender都是不同的实例
    // 其实这个调用没有问题，有问题的是，我需要想办法拆分出来不同的。这样让setState的时候触发正确的函数。
    // Input1.setRootRender(() => {return Input1.render()}, document.querySelector('#root1'))
    // Input2.setRootRender(() => {return Input2.render()}, document.querySelector('#root2'))
    window.Component.prototype.setRootRender(() => {return myFunc()}, document.querySelector('#root1'))
    // (new window.Component()).setRootRender(() => {return Input2.render()}, document.querySelector('#root2'))
</script>
</html>